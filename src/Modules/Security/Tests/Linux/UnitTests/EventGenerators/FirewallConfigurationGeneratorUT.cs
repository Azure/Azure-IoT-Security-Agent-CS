// <copyright file="FirewallConfigurationGeneratorUT.cs" company="Microsoft">
// Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>

using Microsoft.Azure.IoT.Agent.Core.Tests.UnitTests;
using Microsoft.Azure.IoT.Agent.Core.Utils;
using Microsoft.Azure.IoT.Contracts.Events;
using Microsoft.Azure.Security.IoT.Agent.EventGenerators.Linux;
using Microsoft.Azure.Security.IoT.Contracts.Events.Events;
using Microsoft.Azure.Security.IoT.Contracts.Events.Payloads;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Moq;
using Security.Tests.Common.Helpers;
using System.Collections.Generic;
using System.Linq;

namespace Agent.Tests.Linux.UnitTests.EventGenerators
{
    /// <summary>
    /// Unit tests for firewall configuration event generator
    /// </summary>
    [TestClass]
    public class FirewallConfigurationGeneratorUT : UnitTestBase
    {
        private const string OnlyPolicyRules = @"# Generated by iptables-save v1.6.0 on Sat Nov 10 21:05:13 2018
*filter
:INPUT ACCEPT [95:5210]
:FORWARD ACCEPT [0:0]
:OUTPUT REJECT [96:7886]
COMMIT
# Completed on Sat Nov 10 21:05:13 2018
";

        private const string SimpleTable =
            @"# Generated by iptables-save v1.6.0 on Sun Nov 25 11:06:15 2018
*filter
:INPUT ACCEPT [73:3090]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [14:101416]
:NewTable - [0:0]
-A INPUT -p tcp -m multiport --dports 59100 -m multiport --dports 3000 -m state --state NEW -j REJECT --reject-with ""tcp reset""
-A INPUT -g NewTable
-A NewTable -p tcp -m tcp --dport 80 -j ACCEPT
COMMIT
# Completed on Sun Nov 25 11:06:15 2018
";

        private const string NegativeRule =
            @"# Generated by iptables-save v1.6.0 on Sun Nov 25 11:06:15 2018
*filter
:INPUT ACCEPT [73:3090]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [14:101416]
-A INPUT -p tcp -m multiport ! --dports 59100 -m multiport --dports 3000 -j DROP
-A OUTPUT -s 14.12.14.12 -j ACCEPT
-A OUTPUT ! -s 1.2.3.4/12 -j DROP
COMMIT
# Completed on Sun Nov 25 11:06:15 2018
";

        private const string FilterTableNotConfigured =
            @"# Generated by iptables-save v1.6.0 on Sun Nov 25 11:06:15 2018
*security
:INPUT ACCEPT [73:3090]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [14:101416]
COMMIT
# Completed on Sun Nov 25 11:06:15 2018";

        private FirewallConfigurationSnapshotGenerator _genertorUnderTest;

        private Mock<IProcessUtil> _mockedShell;

        /// <summary>
        /// Test init
        /// </summary>
        [TestInitialize]
        public override void Init()
        {
            base.Init();

            Twin.ChangeEventPriority(nameof(FirewallConfigurationSnapshotGenerator), EventPriority.High);

            _mockedShell = new Mock<IProcessUtil>();
            _mockedShell.Setup(m => m.ExecuteProcess(
                    It.IsAny<string>(),
                    It.Is<string>(x => x.Contains("which")),
                    It.IsAny<ErrorHandler>(),
                    It.IsAny<IEnumerable<int>>()))
                .Returns("iptables");

            _genertorUnderTest = new FirewallConfigurationSnapshotGenerator(_mockedShell.Object);
        }

        /// <summary>
        /// Verify normal (happy) flow
        /// </summary>
        [TestMethod]
        public void HappyFlowTest()
        {
            _mockedShell.Setup(m => m.ExecuteProcess(
                    It.IsAny<string>(),
                    It.IsAny<string>(),
                    It.IsAny<ErrorHandler>(),
                    It.IsAny<IEnumerable<int>>()))
                .Returns(SimpleTable);

            var events = _genertorUnderTest.GetEvents().ToList();
            events.ValidateSchema();

            events.ForEach(ev => ev.ValidateSchema());

            Assert.AreEqual(1, events.Count);
            var payload = events.Cast<FirewallConfiguration>()
                .Select(x => x.Payload).First().ToList();

            ValidateSimpleTable(payload);
        }

        /// <summary>
        /// Validates a no-payload event is sent if filter table is not configured.
        /// </summary>
        [TestMethod]
        public void TestDefaultEventIfFilterTableIsNotConfigured()
        {
            _mockedShell
                .Setup(m => m.ExecuteProcess(
                    It.IsAny<string>(),
                    It.IsAny<string>(),
                    It.IsAny<ErrorHandler>(),
                    It.IsAny<IEnumerable<int>>()))
                .Returns(FilterTableNotConfigured);

            var events = _genertorUnderTest.GetEvents();
            events.ValidateSchema();

            ValidateDefaultTableEvent(events);

            _mockedShell.Verify(m => m.ExecuteProcess(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<ErrorHandler>(),
                It.IsAny<IEnumerable<int>>()), Times.Exactly(2));
        }

        /// <summary>
        /// Verifies that no events are created if ip tables does not exist on the machine
        /// </summary>
        [TestMethod]
        public void TestEventIfIpTablesNotExist()
        {
            var mockedShell = new Mock<IProcessUtil>();
            mockedShell.Setup(m => m.ExecuteProcess(
                    It.IsAny<string>(),
                    It.Is<string>(x => x.Contains("which")),
                    It.IsAny<ErrorHandler>(),
                    It.IsAny<IEnumerable<int>>()))
                .Returns("");
            var genertorUnderTest = new FirewallConfigurationSnapshotGenerator(mockedShell.Object);

            var events = genertorUnderTest.GetEvents();

            Assert.AreEqual(0, events.Count());

            mockedShell.Verify(util => util.ExecuteProcess(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<ErrorHandler>(),
                        It.IsAny<IEnumerable<int>>()),Times.Exactly(1));
        }

        /// <summary>
        /// Verifes empty event is created if no rules are configured
        /// </summary>
        [TestMethod]
        public void TestDefaultEvent()
        {
            _mockedShell
                .Setup(m => m.ExecuteProcess(
                    It.IsAny<string>(),
                    It.IsAny<string>(),
                    It.IsAny<ErrorHandler>(),
                    It.IsAny<IEnumerable<int>>()))
                .Returns(string.Empty);

            var events = _genertorUnderTest.GetEvents();
            events.ValidateSchema();

            ValidateDefaultTableEvent(events);

            _mockedShell.Verify(m => m.ExecuteProcess(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<ErrorHandler>(),
                        It.IsAny<IEnumerable<int>>()),Times.Exactly(2));
        }

        /// <summary>
        /// Verifies chain policy rules are parsed ok
        /// </summary>
        [TestMethod]
        public void TestPolicyRules()
        {
            _mockedShell.Setup(m => m.ExecuteProcess(
                    It.IsAny<string>(),
                    It.IsAny<string>(),
                    It.IsAny<ErrorHandler>(),
                    It.IsAny<IEnumerable<int>>()))
                .Returns(OnlyPolicyRules);

            var events = _genertorUnderTest.GetEvents().ToList();
            events.ValidateSchema();

            Assert.AreEqual(1, events.Count());
            var payload = events.Cast<FirewallConfiguration>().Select(x => x.Payload).First().ToList();
            Assert.AreEqual(3, payload.Count());
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.In)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Allow));
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == null)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Allow));
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.Out)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Deny));

            _mockedShell
                .Verify(
                    m => m.ExecuteProcess(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<ErrorHandler>(),
                        It.IsAny<IEnumerable<int>>()),
                    Times.Exactly(2));
        }

        /// <summary>
        /// Test rules with negative arguments are parsed OK
        /// </summary>
        [TestMethod]
        public void TestNegativeRules()
        {
            _mockedShell.Setup(m => m.ExecuteProcess(
                    It.IsAny<string>(),
                    It.IsAny<string>(),
                    It.IsAny<ErrorHandler>(),
                    It.IsAny<IEnumerable<int>>()))
                .Returns(NegativeRule);

            var events = _genertorUnderTest.GetEvents().ToList();
            events.ValidateSchema();

            Assert.AreEqual(1, events.Count());
            var payload = events.Cast<FirewallConfiguration>().Select(x => x.Payload).First().ToList();
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.In)
                .Where(rulePayload => rulePayload.DestinationPort == "!(59100),3000")
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Deny));
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.Out)
                .Where(rulePayload => rulePayload.SourceAddress== "14.12.14.12")
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Allow));
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.Out)
                .Where(rulePayload => rulePayload.SourceAddress == "!(1.2.3.4/12)")
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Deny));

            _mockedShell.Verify(m => m.ExecuteProcess(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<ErrorHandler>(),
                        It.IsAny<IEnumerable<int>>()),Times.Exactly(2));
        }

        private void ValidateDefaultTableEvent(IEnumerable<IEvent> events)
        {
            Assert.AreEqual(1, events.Count());
            var payload = events.Cast<FirewallConfiguration>().Select(x => x.Payload).First().ToList();
            Assert.AreEqual(3, payload.Count());
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.In)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Allow));
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == null)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Allow));
            Assert.AreEqual(1, payload
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.Out)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Allow));
        }

        private void ValidateSimpleTable(IList<FirewallRulePayload> firewallPayloads)
        {
            Assert.AreEqual(6, firewallPayloads.Count);
            Assert.AreEqual(1, firewallPayloads
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.In)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Allow));
            Assert.AreEqual(1, firewallPayloads
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.In)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Other));
            Assert.AreEqual(1, firewallPayloads
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.In)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Deny 
                    && rulepayload.Protocol == "tcp" 
                    && rulepayload.DestinationPort == "59100,3000"));
            Assert.AreEqual(1, firewallPayloads
                .Where(rulePayload => rulePayload.Direction == FirewallRulePayload.Directions.Out)
                .Count(rulepayload => rulepayload.Action == FirewallRulePayload.Actions.Allow));
            Assert.AreEqual(1, firewallPayloads
                .Where(rulePayload => rulePayload.Direction == null)
                .Where(rulePayload => rulePayload.DestinationPort == "80")
                .Where(rulePayload => rulePayload.Protocol == "tcp")
                .Count(rulePayload => rulePayload.Action == FirewallRulePayload.Actions.Allow));
            Assert.AreEqual(1, firewallPayloads
                .Where(rulePayload => rulePayload.Direction == null)
                .Where(rulePayload => rulePayload.ChainName == "FORWARD")
                .Count(rulePayload => rulePayload.Action == FirewallRulePayload.Actions.Allow));
        }
    }
}